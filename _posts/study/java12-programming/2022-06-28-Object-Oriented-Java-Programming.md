---
layout: post
bigtitle: 'Java12 프로그래밍'
subtitle: 객체 지향 자바 프로그래밍
date: '2022-06-28 00:00:00 +0900'
categories:
    - study
    - java12-programming
tags: JAVA12
comments: true
---

# 객체 지향 자바 프로그래밍

# 객체 지향 자바 프로그래밍
* toc
{:toc}

## 개요

### 자바를 쓰면 왜 좋은가요

+ 플랫폼에 영향을 받지 않으므로 다양한 환경에서 사용할 수 있다.
+ 객체지향 언어이기 때문에 유지보수가 쉽고 확장성이 좋다.
+ 프로그램이 안정적이다.
+ 풍부한 기능을 제공하는 오픈 소스다

### 자바로 만들 수 있는 프로그램

+ 웹 서버
+ 안드로이드 앱
+ 게임

## 변수

### 제약 사항

+ 변수의 의미와 목적이 분명히 나타나야 한다.
+ 비슷한 이름은 사용하지 않는다.
+ 줄임말은 지향한다. - 변수길이에 제한이 없으므로 의미를 풀어서 쓰는 것이 좋다.
+ 숫자로 시작 할수 없다.
+ 띄어쓰기를 할수 없다.
+ 특수문자를 사용하지 않는다. - 영문자, 숫자 사용 가능 하고 특수문 자 중 $와 _ 만 사용가능
+ 예약어를 사용하지 않는다. - 자바 프로그램 안에서 특별한 의미로 미리 약속되어 있는 단어
+ Camael Case를 지킨다.
+ 대소문자를 구별한다.

## 자료형

* 자바 라이브러리에서 기본 제공하며, 얼마만큼의 메모리를 사용할 것인지 정해져 있습니다.

|        | 정수형 | 문자형 | 실수형 | 논리형 |
| :----: | ------ | ------ | ------ | ------ |
| 1바이트 | byte |  |  | boolean |
| 2바이트 | short | char |  |
| 4바이트 | int |  | float |  |
| 8바이트 | long |  | double |  |

+ 정수형
> + 양수, 음수, 0을 나타내는 데 사용하는 자료형 입니다.
> + byte
>   + 1바이트, 바이트 단위의 정보를 저장하거나 통신할 때 주로 사용합니다.
>   + 예를 들어, 동영상이나 음악파일을 재생할 때, 데이터를 네트워크로 전송할 때 사용하게 됩니다.
> + short
>   + 2바이트, 정수를 표현하는 자료형
> + int
>   + 4바이트, 컴퓨터에서 정수로 연산할 때 4바이트 단위로 처리하는 것이 가장 효율적이기 때문에 정수 자료형으로 가장 많이 쓰입니다.
> + long
>   + 8바이트, 정수를 표현하는 가장 큰 단위, 간혹 숫자가 int형 범위를 넘는 큰 수인 경우 뒤에 L을 붙여줘야 합니다.

+ 문자형
> + 문자를 나타내는 데 사용하는 자료형
> + 영문자나 특수기호는 1바이트로 가능하지만, 한글 등 복잡한 문자는 1바이트만으로 모든 표현이 불가해서 2바이트 이상을 사용
> + char
>   + 2바이트, 항상 작은따옴표 사용

+ 실수형
> + 부동소수점 방식을 이용해서 더 많은 실수를 좀 더 세밀하게 표현합니다.
> + float
>   + 4바이트, long과 구별하기 위해 뒤에 f를 붙여줍니다.
> + double
>   + 8바이트, 자바에서 기본을 사용합니다.

+ 논리형
> + 어떤 변수의 참, 거짓의 값을 나타내는데 사용합니다.
> + boolean
>   + 1 바이트, true(참) false(거짓) 두 가지 값만 가집니다.

+ 자료형 없이 변수 선언
> + 자바 10부터는 자료형을 쓰지 않고도 변수를 선언할 수 있습니다. 이를 지역 변수 자료형 추론이라고 합니다.
> + 변수에 대입 되는 자료를 보고 컴파일가 추측하여 자료형을 알 수 있습니다.

+ 상수(constant)
> + 변환해야 하는 변수가 있다면, 변하지 않아야 하는 수도 필요합니다.
> + 예를 들어 운주율을 구하는 3.14라든지, 1년이 12개월이라는 수도 변하지 않는 수 입니다.
> + 자바에서는 상수는 이러한 상수를 final로 선언합니다.
> + 한 번 선언한 상수는 변하지 않기 때문에 동시에 값을 지정하는게 좋음
> + 상수의 경우 이후에 재할당을 하려하면 오류 발생

+ String 클래스
> + JAVA 가 제공하는 char 데이터 타입은 문자 하나 저장
> + 여러 개의 문자르 저장하기 위해 String 사용
> + new 키워드를 사용하지 않고 생성할 수 있음 , 기본 타입 처럼 사용
> + 기본 타입처럼 사용하지만 참조 타입이기 때문에 메소드를 갖고 있다는 점에 주의해야함
> + 쌍따옴표를 사용

## Array

+ Array 복사하기
  + 크기가 같은 배열을 새로 만들어야 하거나, 더 큰 배열을 만들기 위해 기존 배열에 저장된 자료를 가져오려 할 때 배열을 복사 한다.
  + for문을 이요하여 각 요소 값을 복사하거나 , System.arraycopy() 메소드를 사용하여 복사

* System.arraycopy(src,srcPos,destPos,length)

| 매개변수 | 설명 |
| :-----: | ---- |
|src| 복사할 배열 이름 |
|srcPos| 복사할 배열의 첫 번째 위치 |
|dest| 복사해서 붙여 넣을 대상 배열 이름 |
|destPos| 복사해서 대상 배열에 붙여 넣기를 시작할 첫 번째 위치 |
|length| src에서 dest로 자료를 복사할 요수 개수 |   

~~~java
public class ArrayCopy {
    public static void main(String[] args) {
        int[] array1 = {10, 20, 30, 40, 50};
        int[] array2 = {1, 2, 3, 4, 5};
        System.arraycopy(array1, 0, array2, 1, 4);
        for (int i = 0; i < array2.length; i++) {
            System.out.println(array2[i]);
        }
    }
}
~~~

## Scope of varlables

+ 변수는 어디에 선언되느냐에 따라 그 범위가 달라짐
  + 지역변수
    + 함수나 메소드 내에 사용
    + 함수 밖에서는 사용 불가
    + 지역변수가 생성되는 메모리를 스택(stack)이라고 함
    + 지역변수는 함수가 호출될 때 생성
    + 함수가 리턴되면 메모리 공간이 해제되어 함께 없어짐
  + 멤버변수(인스턴스 변수)
    + 클래스가 생성될 때 힙(heap)메모리에 생성
    + 클래스 어느 메소드에서나 사용이 가능
    + 힙에 생성된 인스턴스가 가비지 컬렉터에 의해 수거되면 메모리에서 사라짐

## 메소드

+ 접근 제한자

| 접근 제한자 | 클래스 내부 | 동일 패키지 | 하위 클래스 | 그 외의 영역 |
| :--------: | :----------: | :----------: | :----------: | :----------: |
|public| O | O | O | O |
|protected| O | O | O | X |
|default| O | O | X | X |
|private| O | X | X | X |

> + public이라고 선언한 변수나 메서드는 외부 클래스에서 접근이 가능하며 외부 클래스가 사용할 수 없다는 뜻
> + private라고 선언한 변수나 메서드는 외부 클래스의 접근이 허용되지 않음
> + protected 같은 패키지 내부와 상속관계의 클래스만 접근할 수 있고, 그 외 클래스에서 접근할 수 없음


+ 클래스 내부에서 사용할 변수나 메서드는 private 선언해서 외부에서 접근하지 못하도록 하는 것을 객체 지향에서는 "정보 은닉(information hiding)"이라고 함 
  + 모든 변수를 private으로 선언해야 하는 것은 아니지만 필요한 경우에는 private으로 선언하여 오류를 막을 수 있음

## static

+ static
  + static 변수를 클래스변수라고도 하는데 이는 인스턴스마다 생성되는 변수가 아니라. 클래스에 속한 한번만 생성되는 변수이고 이를 여러 인스턴스가 공유하기 때문이다.
  + 메소드나 멤버변수가 static으로 변경이 되면, 객체화 없이 사용할 수 있습니다.
  + 단순 반복 처리 작업을 해야 할 경우 조종사용
  + static 변수는 인스턴스보다 먼저 생성
  + 클래스에 속해 한 번만 생성되는 변수이고 이를 여러 인스턴스가 공유, 이러한 이유로 static 변수를 클래스에 기반한 변수라고 해서 클래스 변수라고도 함
  + static 변수를 위한 메소드는 static 메소드 또는 클래스 메소드 라고 함
  
+ static 변수의 유효 범위
  + 프로그램 실행 시 메모리에 프로그램에 상주하게 되는데, 프로그램 영역 중 데이터 영역에 있음.
  + 데이터 영역에는 상수나 문자열 , static 변수가 생성
  + 멤버변수와 static 변수는 사용하는 메모리가 다름
  + static 변수는 프로그램이 시작할 때부터 끝날 때까지 메모리에 상주하고 있기 때문에 크기가 너무 큰 변수는 선언하지 않는 것이 좋음

| 변수 유형 | 선언 위치 | 사용 범위 | 메모리 | 생성과 소멸 |
| :-------: | :------: | :------: | :---: | :---------: |
| 지역변수<br/>(로컬변수) | 함수 내부 | 함수 내부 | 스텍 | 함수 호출될 때 생성되고 함수가 끝나면 소멸 |
| 멤버변수<br/>(인스턴스 변수) | 클래스 선언 바로 아래 | 클래스 내부, private이 아니면 참조변수로 다른 클래스에서 사용 가능 | 힙 | 인스턴스 생성되고, 가비지컬렉터가 메모리 수거할 때 소멸 |
| static변수<br/>(클래스변수) | static 예약어를 사용하여 클래스 내부에서 선언 | 클래스 내부, private이 아니면 클래스 이름으로 다른 클래스에서 사용가능 | 데이터(static)영역 | 프로그램 실행 시 생성되고, 프로그램이 끝날 때 소멸 |

+ 싱글톤 패턴(singleton patten)
  + 프로그램 구현 시 인스턴스 하나만 생성하는 디자인 패턴
  
## 상속 

+ 하위클래스가 생성될 때는 상위 클래스의 생성자가 먼저 호출되는데, 그래서 하위클래스가 상위클래스의 변수와 메소드를 사용할 수 있고, 상위 클래스의 자료형으로 형변환이 가능해짐 , 반대로 하위클래스의 자료형으로 상위클래스의 인스턴스는 생성은 불가능

+ IS-A 관계 (is a relationship; inheritance)
  + 일반적인 개념과 구체적인 개념과의 관계
  + 사람은 포유류이다 와 같은 관계처럼 상속은 IS-A 관계에서 사용하는 것이 가장 효율적
  + 일반 클래스를 점차 구체화하는 상황에서 상속을 사용하는 것
  + 단순히 코드를 재사용할 목적으로 서로 관련이 없는 개념의 클래스들을 상속 관계로 사용하는 것은 좋지 않은 코드 작성법
+ HAS-A 관계(has a relationship; association)
  + 한 클래스가 다른 클래스를 소유한 관계
  + 예를 들어 학생이 있고 수강하는 과목이 있다고 했을 때 학생이 과목을 포함하진 않음
  + 과목은 학생에 포함되어 멤버 변수로 사용하느것이 적절함
  + 상속을 사용하면 클래스 간의 결합도가 높아져서 상위 클래스의 변화가 하위클래스에 미치는 여향이 큼 따라서 상속은 코드 재사용 개념으로 이해하지 말고  일반적인 클래스 와 구체적인 클래스의 관계에서 구현해야함

## 추상클래스

+ 템플릿 메소드
  + 템플릿 메소드의 역할은 메소드 실행 순서와 시나리오를 정의하는 것
  + 템플릿 메소드에서 호출하는 메소드가 추상 메소드라면 차종에 따라 구현 내용이 바뀔 수는 있다.
  + 템플릿 메소드는 시나리오를 정의한 메소드이므로 바뀔 수 없다. 상속받은 하위 클래스에서 탬플릿 메소드를 재정의하면 안된다는 것
  + 템플릿 메소드는 final 예약어를 사용해 선언해서 템플릿 메소드 재정의가 안된다고 구현하는 것

        final로 선언된 경우 다른 값을 대입할 수 없음
        자바 프로젝트를 진행할 때 여러 파일에서 공유해야 하는 상수 값은 한 파일에 모아 public static final로 선언하여 사용

        클래스를 final로 선언하면 상속할 수 없음
        상속을 하면 재정의가 가능한데, 원래 클래스가 가지고 있는 기능에 오류가 생길 수 있기 때문에
        보안과 관련되어 있거나 기반 크래스가 변하면 안되는 경우에는 클래스를 final로 선언

## interface

+ 디폴트 메소드
  + 디폴트 메소드는 인터페이스에서 구현 코드까지 작성한 메소드
  + 인터페이스를 구현한 클래스가 생성되면 그 클래스에서 사용할 기본 기능
  + 디폴티 메소드를 선언할 때는 default 예약어를 사용
  + 디폴트 메소드는 인터페이스에 이미 구현이되어 있으므로 추상 클래스나 추상 클래스를 상속받은 클래스에서 코드를 구현할 필요가 없음
+ 메소드 자료형 앞에 static 예약어를 사용하여 정적 메소드 추가가 가능
+ 한 클래스가 여러 클래스를 상속받으면 메서드 호출이 모호해지는 문제가 발생할 수 있음 하지만 인터페이스는 한 클래스가 여러 인터페이스를 구현할 수 있음
  + 인터페이스는 구현코드나 멤버변수를 가지지 않기 때문에 여러 개를 동시에 구현할 수 있음
  + 두 인터페이스에 이름이 같은 메소드가 선언되었다고 해도 구현은 클래스에서 이루어지므로 어떤 메소드를 호출해야 하는지 모호 하지 않음
  + 인터페이스의 디폴트 메서드는 다중상속의 모호성 문제를 해결하기 위해서 자식 클래스에서 반드시 해당 메서드를 Override 해야한다
+ 인터페이스 간에도 상속이 가능
  + 인터페이스 간 상속은 구현코드를 통해 기능을 상속하는 것이 아니므로 형 상속(type inheritance) 라고 부름
  + 클래스의 경우 하나의 클래스만 상속받을 수 있지만 인터페이스는 여러 개를 동시에 상속받을 수 있음
+ 추상클래스와 인터페이스의 차이
  + 디폴트메소드를 사용함으로써 인터페이스는 메소드를 선언뿐만 아니라 구현까지 가능하게 되었고 추상 클래스는 불가능한 다중 상속까지 지원을 하니 추상클래스를 사용할 필요없이 전부 인터페이스를 implements하는 구조로 하면 되는것이 아닌가 라는 의문이 생김 하지만 클래스와 인터페이스는 차이점이 존재
    + 인터페이스는 public 접근제한자만 가능
    + 인터페이스는 생성자를 가질 수 없음

## 예외처리

+ 오류클래스 모두 Throwable 클래스에서 상속 받음
  + Error 클래스의 하위 클래스는 시스템에서 발생하는 오류를 다루며 프로그램에서 제어하지 않음
  + 프로그램에서 제어하는 부분은 Exception클래스와 그 하위의 예외 클래스

## 컬렉션 프레임워크

+ 자바에서는 필요한 자료 구조를 미리 구현하여 java.util 패키지에서 제공, 이 라이브러리를 컬레션 프레임워크(collection framework)라고 함
  + 자바 컬렉션 프레임워크에는 여러 인터페이스가 정의되어 있고, 그 인터페이스를 구현한 클래스가 있음.
  + Collection 인터페이스는 하나의 자료를 모아서 관리하는데 필요한 기능을 제공
  + Map 인터페이스는 쌍으로 된 자료들을 관리하는 데 유용한 기능을 제공

<div class="language-mermaid">
graph TD;
    Collection-->List;
    Collection-->Set;
    List-->ArrayList;
    List-->Vector;
    List-->LinkedList;
    Set-->HashSet;
    Set-->TreeSet;
</div>

<div class="language-mermaid">
graph TD;
    Map-->HashTable;
    Map-->HashMap;
    Map-->TreeMap;
    HashTable-->Properties;
</div>

+ Collection 인터페이스는 하위에 List 인터페이스와 Set 인터페이스가 있다
  + List를 구현한 클래스는 순차적인 자료를 관리
  + Set을 구현한 클래스는 집합을 생각하면 됨
+ Map 인터페이스는 하나가 아닌 쌍(pair)으로 선언되어 있는 자료를 관리하는 메소드들이 선언되어 있음
  + key 값은 중복될 수 없음
  + Map은 기본적으로 검색용 자료구조
  + 어떤 key 값을 알고 있을 때 value를 찾기 위한 자료구조
+ Map 인터페이스는 모든 자료를 한번에 순회할 수 있는 방법이 없음
  + 모든 자료를 순회할려면 key값을 먼저 가져와서 key 값에 해당하는 value를 찾아야함
  + hashMap.keySet()메소드를 호출하면 모든 key값이 Set 객체로 반환
  + 반환된 set()객체에 interator()메소드를 호출하면 key를 순회할 수 있는 interator가 반환