---
layout: post
bigtitle: '우아한테크코스 테코톡'
subtitle: 이브, 배카라의 Synchronization
date: '2022-11-20 00:00:00 +0900'
categories:
    - elegant-tekotok
comments: true
---

# 이브, 배카라의 Synchronization
[https://youtu.be/ImWjQ1Bxjrs](https://youtu.be/ImWjQ1Bxjrs)

# 이브, 배카라의 Synchronization
* toc
{:toc}

## 사전 지식 
+ CPU 동작 방식
  + 프로세스는 CPU의 자원이 있어야만 본인의 할 일을 실행할 수 있다. 
  + Context switch를 통해서 CPU 자원을 서로 번갈아 가며 얻어가면서 코드 실행과 대기를 반복하는 방식으로 동작하게 된다.
  + 컴표터에서는 이 과정이 굉장히 빠르게 실행되기 때문에 두 개의 프로세스가 동시에 실행되는 것처럼 보인다. 
  + 멀티프로세서 환경은 CPU 각각 할당이 되어있는 경우 동시에 실행을 한다.
+ 프로세스와 스레드
  + 프로세스는 메모리 내에서 작업을 하는 하나의 작업 단위이다.
  + 하나의 프로세스 내에서 스레드라는 여러 실행 흐름으로 나뉘는데 이거를 멀티스레딩 방식이라고 한다. 
  + 프로세스는 자기 내부에서 여러 개의 스레드를 가짐으로써 실행 흐름을 여러 개로 나눠서 실행할 수가 있다 이때 스레드들고 CPU 자원을 얻어야만 실행할 수 있기 때문에 하나의 프로세스에 내에서 하나의 CPU를 번갈아 가면서 얻어가는 방식으로 진행을 한다.

## 공유 자원 동시 접근 문제 
+ count++;
  1. 메모리에서 가져오기 (LOAD)
  2. 연산 수행 (INC)
  3. 메모리에 저장 (STORE)
+ 경쟁 상태(Race condition)
  + 공유 자원에 동시에 여러 개의 프로세스가 접근하려고 할 때, 그 실행 결과가 접근이 발생한 특정 순서에 의존하는 상황
+ 임계 구역(Critical section)
  + 공유 자원에 접근하는 부분 

## 경쟁 상태 발생 상황 - 프로세스와 스레드
+ 멀티 스레딩 환경에서 경쟁 상태 발생 상황
  + ![img.png](../../../assets/img/elegant-tekotok/EVE-BAKHARA-Synchronization.png)
  + 스레드는 하나의 프로세스 내에서 여러 개로 나뉜 실행 흐름 단위이기 때문에 지역변수 저장을 위한 스택(Stack)은 스레드 별로 각자 갖지만 나머지 프로세스 데이터들은 똑같은 메모리 영역을 참조한다.
  + 그래서 스레드들이 프로세스의 공유 데이터 영역에 접근하는 순간 경쟁 상태가 발생할 수 있다.
+ 프로세스 경쟁 상태 발생 상황
  + 프로세스는 메모리에 내에서 각자 독립적인 주소 공간을 갖는 작업의 단위이다. 
  + 원칙적으로는 다른 프로세스의 주소 공간에 접근하지 않는데 어떤 상황에서 경쟁 상태가 발생할 수 있을까?
    + 커널 내부 데이터에 접근한는 루틴 
      + 커널: 운영체제는 CPU를 포함한 여러 하드웨어 자원들을 효율적으로 관리하는 역할을 한다. 만약에 악의적인 프로세스가 디스크나 다른 프로세스의 주소 공간에 접근하려고 하면 운영체제는 이를 방지할 수 있어야한다.
      하드웨어에서는 운영체제를 지원하기 위해 두 가지의 실행 모드를 지원해준다.
      + 유저모드: 디스크 입출력과 같은 하드웨어 자원에 대한 접근 권한 일부 제한
      + 커널모드: 모든 하드웨어 자원에 접근 가능  
      + ![img.png](../../../assets/img/elegant-tekotok/EVE-BAKHARA-Synchronization2.png)
    + 커널 내부 데이터에 접근한는 루틴 - 멀티 프로세서
      + 컨텍스트 스위칭을 발생하지 않겠지만 실행 순서에 따른 이슈는 남아 있다. 
    + 협력적인 프로세스 
      + 정보 공유 (ex - 공유 폴더)
      + 빠른 테스크 처리를 위한 병렬 처리 프로세스
      + 여러 프로세스들이 협력하는 모듈 형태의 시스템
      + 프로세스들이 협력하기 위해서는 별도의 프로세스간 통신 기법이 필요하다 
        + Shared Memory(공유 메모리 환경)에서 프로세스간 메모리 영역을 공유하며 협력
          + 실제 물리적인 메모리 영역을 공유하기 때문에 아까 같은 경쟁 상태가 발생할 수 있다

## 동기화 기법 
+ 주로 OS 레벨에서 제공한느 대표적인 동기화 기법인 뮤텍스(Mutex)와 세마포어(Semaphore)에 대해서 설명 
+ Lock(mutex)
  + 상호 배제(Mutual exclusion)
  + 하나의 프로세스가 임계 영역 내에 있다면 이 프로세스의 동작이 끝날 때까지 다른 프로세스가 임계 영역에 들어 올 수 없도록 제한하는 알고리즘
  + ![img.png](../../../assets/img/elegant-tekotok/EVE-BAKHARA-Synchronization3.png)
  + 운영체제에서는 뮤텍스를 위해 락이라는 메커니즘을 제공한다. 
  + 락은 구현 방법에 따라서 한 가지 성능 이슈가 존재하는데 스핀락(Spin lock)이라는 이슈이다.

## Spin lock
+ 공유 자원에 접근할 때 lock이라는 메서드를 사용하는데 만약에 락이 이미 걸려있다면, 누군가 이미 공유 자원을 사용하고 있다면  while 문이 락이 해제될 때까지 돌게 되는 것을 스핀락이라고 한다.
+ 시스템 전체적으로 자원이 낭비된다. 
+ 다른 방식의 Lock (Sleep 방식)
  + 이미 락이 걸려 있다면 Sleep 상태로 변경한다. 이후에 락이 풀리면 Sleep 상태에서 깨서 접근할 수 있게 된다 Sleep 상태에서 깨면 깰 시간이 필요하다 Sleep 상태 변경 전에 어떤 거 했는지에 관한 시간이 필요하다 컨텍스 스위치 하는 시간이 필요하다.
+ Spin lock 성능이 더 좋은 상황
  + 공유 자원 사용 시간 < Context Switch 시간
    + 공유 자원 사용 시간이 컨텍스트 스위치 비용보다 짧다면 Spin lock이 더 좋은 성능을 발휘할 수 있다. 
    + Sleep 상태로 만드는 락의 경우는 컨텍스트 스위치 시간이 필요하다, 컨텍스트 스위치는 많은 시간을 잡아 먹기 때문에 공유 자원 사용 시간이 컨텍스트 스위치 시간보다 짧다면 굳이 컨텍스트 스위치 시간을 가질 필요가 없다.
    근데 이경우 멀티 코어일 때만 적용이 된다.
  + 공유 자원 사용 시간 < Context Switch 시간 + 멀티 코어 
    + 싱글 코어일 경우에는 스핀 락의 성능이 더 좋지 않다. 
      + Context Switch가 발생하는 싱글 코어에서는 Spin lock 성능이 더 좋지 않게 된다.  

## Semaphore
+ 공유자원의 접근을 제한하는 정수형 변수를 이용해서 공유 자원에 대한 접근을 제한하는 방법
+ 세마포어는 count 변수와 대기 큐를 갖고 있다. 

## Mutex와 Semaphore
+ Mutex
  + 공유 자원에 대한 접근을 제한하기 위한 동기화 메커니즘
  + 임계 구역에 하나의 프로세스만 진입할 수 있다.
+ Semaphore
  + 공유 자원에 대한 접근을 제한하기 위한 동기화 메커니즘
  + 임계 구역에 여러 개의 프로세스가 진입할 수 있다.

