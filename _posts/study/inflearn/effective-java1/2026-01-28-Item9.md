---
layout: post
bigtitle: '이펙티브 자바 완벽 공략 1부'
subtitle: 아이템 9. try-finally 보다 try-with-resouces를사용하라
date: '2026-01-28 00:00:01 +0900'
categories:
- effective-java1
comments: true

---

# 아이템 9. try-finally 보다 try-with-resouces를사용하라

# 아이템 9. try-finally 보다 try-with-resouces를사용하라

* toc
{:toc}

---

## 핵심 정리

* Java 7부터(`Java 8 이상`을 사용 중이라면 더욱)
  **자원 회수에 try-finally는 더 이상 최선의 방법이 아니다**
* `try-with-resources`는

    * 코드가 더 짧고
    * 더 안전하며
    * 예외 정보까지 더 정확하게 보존한다

---

### try-finally 방식의 한계

#### 단일 자원일 때조차 불편하다

```java
// 코드 9-1 try-finally - 더 이상 자원을 회수하는 최선의 방책이 아니다! (47쪽)
static String firstLineOfFile(String path) throws IOException {
    BufferedReader br = new BufferedReader(new FileReader(path));
    try {
        return br.readLine();
    } finally {
        br.close();
    }
}
```

* 코드 자체는 단순해 보이지만
* 자원이 늘어나는 순간 복잡도가 급격히 증가한다

---

#### 자원이 둘 이상이면 코드가 급격히 지저분해진다

```java
// 코드 9-2 자원이 둘 이상이면 try-finally 방식은 너무 지저분하다! (47쪽)
static void copy(String src, String dst) throws IOException {
    InputStream in = new FileInputStream(src);
    try {
        OutputStream out = new FileOutputStream(dst);
        try {
            byte[] buf = new byte[BUFFER_SIZE];
            int n;
            while ((n = in.read(buf)) >= 0)
                out.write(buf, 0, n);
        } finally {
            out.close();
        }
    } finally {
        in.close();
    }
}
```

* 자원이 늘어날수록 중첩 `try-finally`가 증가
* 가독성 급격히 저하
* 실수 가능성 증가

---

#### 중첩을 피하려다 더 위험해지는 경우

아래 코드는 **겉보기엔 깔끔해 보이지만 위험한 코드**다.

```java
static void copy(String src, String dst) throws IOException {
    InputStream in = new FileInputStream(src);
    OutputStream out = new FileOutputStream(dst);
    try {
        byte[] buf = new byte[BUFFER_SIZE];
        int n;
        while ((n = in.read(buf)) >= 0)
            out.write(buf, 0, n);
    } finally {
        in.close();
        out.close();
    }
}
```

##### 문제점

* `in.close()`에서 예외가 발생하면
* `out.close()`는 **절대 호출되지 않는다**
* 결과적으로 **자원 누수(resource leak)** 발생 가능

👉 try-finally는 **조심해서 써야 하는 패턴**이지, 안전한 기본값이 아니다.

---

### try-with-resources: 자원 회수의 최선책

#### 단일 자원

```java
// 코드 9-3 try-with-resources - 자원을 회수하는 최선책! (48쪽)
static String firstLineOfFile(String path) throws IOException {
    try (BufferedReader br = new BufferedReader(
            new FileReader(path))) {
        return br.readLine();
    }
}
```

* 코드가 훨씬 짧다
* 자원 반납이 명확하다
* 실수할 여지가 거의 없다

---

#### 복수 자원

```java
// 코드 9-4 복수의 자원을 처리하는 try-with-resources - 짧고 매혹적이다! (49쪽)
static void copy(String src, String dst) throws IOException {
    try (InputStream   in = new FileInputStream(src);
         OutputStream out = new FileOutputStream(dst)) {
        byte[] buf = new byte[BUFFER_SIZE];
        int n;
        while ((n = in.read(buf)) >= 0)
            out.write(buf, 0, n);
    }
}
```

* 선언 순서의 **역순으로 자동 close**
* 모든 자원이 **반드시 닫힌다**
* 중첩 없음, 실수 없음

---

### 예외 정보가 훨씬 유용하다

이 부분이 try-with-resources의 **가장 큰 숨은 장점**이다.

#### try-finally의 문제

* 가장 나중에 발생한 예외만 남는다
* 최초 예외는 완전히 사라질 수 있다
* 디버깅 시 **가장 중요한 정보가 손실**

특히,

* 첫 번째 예외가 원인
* 이후 예외는 후속 증상인 경우가 많다

하지만 try-finally에서는
👉 **첫 번째 예외가 먹혀버릴 수 있다**

---

#### try-with-resources의 장점

* **가장 처음 발생한 예외가 유지된다**
* close() 중 발생한 예외는

    * `suppressed exception`으로 함께 보존된다
* 결과적으로 **문제의 원인을 정확히 파악 가능**

---

### catch 절과 함께 사용하기

`try-with-resources`는
`try-catch-finally` 구조를 그대로 지원한다.

```java
// 코드 9-5 try-with-resources를 catch 절과 함께 쓰는 모습 (49쪽)
static String firstLineOfFile(String path, String defaultVal) {
    try (BufferedReader br = new BufferedReader(
            new FileReader(path))) {
        return br.readLine();
    } catch (IOException e) {
        return defaultVal;
    }
}
```

* 필요하다면 `catch` 추가 가능
* 필요하다면 `finally`도 추가 가능
* **표현력은 유지하면서 안전성만 높아진다**

---

### 이 섹션의 핵심 메시지

* try-finally는 **이제 권장되는 기본 패턴이 아니다**
* try-with-resources는

    * 코드가 짧고
    * 자원 누수를 막아주며
    * 예외 정보까지 온전히 보존한다
* Java 7 이후라면
  👉 **자원 관리의 기본값은 항상 try-with-resources다**

---


## 완벽 공략
+ p48, 자바 퍼즐러 예외 처리 코드의 실수
+ P49, try-with-resources 바이트코드
