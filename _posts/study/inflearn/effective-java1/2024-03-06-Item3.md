---
layout: post
bigtitle: '이펙티브 자바 완벽 공략 1부'
subtitle: 아이템 3. 생성자나 열거 타입으로 싱글턴임을 보증하라.
date: '2024-03-06 00:00:01 +0900'
categories:
- effective-java1
comments: true

---

# 아이템 3. 생성자나 열거 타입으로 싱글턴임을 보증하라.

# 아이템 3. 생성자나 열거 타입으로 싱글턴임을 보증하라.

* toc
{:toc}

## 아이템 3. 핵심 정리 1 - 생성자를 사용하는 방법 1
첫번째 방법: private 생성자 + public static final 필드
+ ![img.png](../../../../assets/img/effective-java1/item3KeyTheorem1.png)
  
+ 장점, 간결하고 싱글턴임을 API에 들어낼 수 있다
  + Static Final로 선언을 해두면 자바 도큐먼트를 만들 때 별도의 필드로 보여준다
  
~~~java

public class Elvis implements IElvis, Serializable {

    /**
     * 싱글톤 오브젝트
     */
    public static final Elvis INSTANCE = new Elvis();
    private static boolean created;

    private Elvis() {
        if (created) {
            throw new UnsupportedOperationException("can't be created by constructor.");
        }

        created = true;
    }

    public void leaveTheBuilding() {
        System.out.println("Whoa baby, I'm outta here!");
    }

    public void sing() {
        System.out.println("I'll have a blue~ Christmas without you~");
    }

    // 이 메서드는 보통 클래스 바깥(다른 클래스)에 작성해야 한다!
    public static void main(String[] args) {
        Elvis elvis = Elvis.INSTANCE;
        elvis.leaveTheBuilding();
    }

    private Object readResolve() {
        return INSTANCE;
    }

}

~~~

+ 단점 1, 싱글톤을 사용하는 클라이언트 테스트하기 어려워진다.
  + 인터페이스가 없는 경우 목 객체를 만들수 없어 테스트하기 어려워진다
+ 단점 2, 리플렉션으로 private 생성자를 호출할 수 있다

~~~java

public class ElvisReflection {

    public static void main(String[] args) {
        try {
            Constructor<Elvis> defaultConstructor = Elvis.class.getDeclaredConstructor();
            defaultConstructor.setAccessible(true);
            Elvis elvis1 = defaultConstructor.newInstance();
            Elvis elvis2 = defaultConstructor.newInstance();
            Elvis.INSTANCE.sing();
        } catch (InvocationTargetException | NoSuchMethodException | InstantiationException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }

}


~~~

+ 단점 3, 역직렬화 할 때 새로운 인스턴스가 생길 수 있다

~~~java

public class ElvisSerialization {

    public static void main(String[] args) {
        try (ObjectOutput out = new ObjectOutputStream(new FileOutputStream("elvis.obj"))) {
            out.writeObject(Elvis.INSTANCE);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (ObjectInput in = new ObjectInputStream(new FileInputStream("elvis.obj"))) {
            Elvis elvis3 = (Elvis) in.readObject();
            System.out.println(elvis3 == Elvis.INSTANCE);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

}

~~~

## 아이템 3. 핵심 정리 2 - 생성자를 사용하는 방법 2
두번째 방법: private 생성자 + 정적 팩터리 메서드
+ ![img.png](../../../../assets/img/effective-java1/item3KeyTheorem2.png)
+ 장점 1. API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다.
  + 클라이언트 코드는 계속해서 동일하게 get 인스턴스를 쓰니까 클라이언트 코드가 변경되지 않으면서 우리가 원하는 대로 동작을 바꿀 수 있게 된다

~~~java

public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis() { }
    public static Elvis getInstance() { return INSTANCE; }

    public void leaveTheBuilding() {
        System.out.println("Whoa baby, I'm outta here!");
    }

    // 이 메서드는 보통 클래스 바깥(다른 클래스)에 작성해야 한다!
    public static void main(String[] args) {
        Elvis elvis = Elvis.getInstance();
        elvis.leaveTheBuilding();

        System.out.println(Elvis.getInstance());
        System.out.println(Elvis.getInstance());
    }
    
}


~~~

+ 장점 2. 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다
  + Generic한 타입으로 동일한 Singleton Instance를 사용하고 싶을 때 Generic Singleton Factory를 만들어 사용할 수 있다
  + Generic한 타입을 쓸 때 인스턴스는 동일하지만 각각이 원하는 타입으로 바꿔서 쓸 수 있다
  + equals로는 비교가 가능한데 type 자체가 다르기 때문에 ```==```  비교는 안된다
  + 제네릭 싱글턴 팩토리에서 해주는 일은 단순하게 가지고 있는 원래 싱글턴 인스턴스를 원하는 타입으로 변환해주는 일만 하는 것이다

~~~java

public class MetaElvis<T> {

    private static final MetaElvis<Object> INSTANCE = new MetaElvis<>();

    private MetaElvis() { }

    @SuppressWarnings("unchecked")
    public static <E> MetaElvis<E> getInstance() { return (MetaElvis<E>) INSTANCE; }

    public void say(T t) {
        System.out.println(t);
    }

    public void leaveTheBuilding() {
        System.out.println("Whoa baby, I'm outta here!");
    }

    public static void main(String[] args) {
        MetaElvis<String> elvis1 = MetaElvis.getInstance();
        MetaElvis<Integer> elvis2 = MetaElvis.getInstance();
        System.out.println(elvis1);
        System.out.println(elvis2);
        elvis1.say("hello");
        elvis2.say(100);
    }

}

~~~

+ 장점 3. 정적 팩터리의 메서드 참조를 공급자(Supplier)로 사용할 수 있다.
  + 책에서 말하는 공급자, Supplier는 Java 8에 들어간 Functional Interface 를 이야기하는 것이다 Java 8에는 ```@FunctionalInterface``` 라는 애노테이션이 붙어 있는 기본적인 Function들을 제공한다
  + Supplier 인터페이스만 만족하면 어떤 메소드든 서플라이어 Functional 타입으로 우리가 사용할 수 있다.


~~~java

public interface Singer {

    void sing();
}


~~~

~~~java

public class Elvis implements Singer {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis() { }
    public static Elvis getInstance() { return INSTANCE; }

    public void leaveTheBuilding() {
        System.out.println("Whoa baby, I'm outta here!");
    }

    // 이 메서드는 보통 클래스 바깥(다른 클래스)에 작성해야 한다!
    public static void main(String[] args) {
        Elvis elvis = Elvis.getInstance();
        elvis.leaveTheBuilding();

        System.out.println(Elvis.getInstance());
        System.out.println(Elvis.getInstance());
    }

    @Override
    public void sing() {
        System.out.println("my way~~~");
    }
}

~~~

~~~java

public class Concert {

    public void start(Supplier<Singer> singerSupplier) {
        Singer singer = singerSupplier.get();
        singer.sing();
    }

    public static void main(String[] args) {
        Concert concert = new Concert();
        concert.start(Elvis::getInstance);
    }
}


~~~

+ 단점은 리플렉션에 대한 문제, 테스트에 대한 문제, 직렬화, 역직렬화 문제 그대로 다 가지고있다

## 아이템 3. 핵심 정리 4 - 열거 타입
세번째 방법: 열거 타입
+ ![img.png](../../../../assets/img/effective-java1/item3KeyTheorem3.png)
+ 가장 간결한 방법이며 직렬화와 리플렉션에도 안전하다
+ 대부분의 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법이다.

## 완벽 공략
+ p23, 리플렉션 API로 private 생성자 호출하기
+ p24, 메서드 참조를 공급자로 사용할 수 있다
+ p24, Supplier<T>, 함수형 인터페이스
+ p24, 직렬화, 역직렬화, Serializable, transient

## 아이템 3. 완벽 공략 11 - 메서드 참조
메소드 하나만 호출하는 람다 표현식을 줄여쓰는 방법
+ 스태틱 메소드 레퍼런스

~~~java

public class Person {

    LocalDate birthday;

    public Person() {

    }

    public Person(LocalDate birthday) {
        this.birthday = birthday;
    }

    public static int compareByAge(Person a, Person b) {
        return a.birthday.compareTo(b.birthday);
    }

    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person(LocalDate.of(1982, 7, 15)));
        people.add(new Person(LocalDate.of(2011, 3, 2)));
        people.add(new Person(LocalDate.of(2013, 1, 28)));

        people.sort(Person::compareByAge);
    }

    public int getAge() {
        return LocalDate.now().getYear() - birthday.getYear();
    }

}


~~~

+ 인스턴스 메소드 레퍼런스

~~~java

public class Person {

    LocalDate birthday;

    public Person() {

    }

    public Person(LocalDate birthday) {
        this.birthday = birthday;
    }

    public int compareByAge(Person a, Person b) {
        return a.birthday.compareTo(b.birthday);
    }

    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person(LocalDate.of(1982, 7, 15)));
        people.add(new Person(LocalDate.of(2011, 3, 2)));
        people.add(new Person(LocalDate.of(2013, 1, 28)));

        Person person = new Person(null);

        people.sort(person::compareByAge);
    }

    public int getAge() {
        return LocalDate.now().getYear() - birthday.getYear();
    }

}

~~~

+ 임의 객체의 인스턴스 메소드 레퍼런스

~~~java

public class Person {

  LocalDate birthday;

  public Person() {

  }

  public Person(LocalDate birthday) {
    this.birthday = birthday;
  }

  public int compareByAge(Person b) {
    return this.birthday.compareTo(b.birthday);
  }

  public static void main(String[] args) {
    List<Person> people = new ArrayList<>();
    people.add(new Person(LocalDate.of(1982, 7, 15)));
    people.add(new Person(LocalDate.of(2011, 3, 2)));
    people.add(new Person(LocalDate.of(2013, 1, 28)));

    people.sort(Person::compareByAge);
  }

  public int getAge() {
    return LocalDate.now().getYear() - birthday.getYear();
  }

}

~~~


+ 생성자 레퍼런스

~~~java

public class Person {

    LocalDate birthday;

    public Person() {

    }

    public Person(LocalDate birthday) {
        this.birthday = birthday;
    }

    public int compareByAge(Person b) {
        return this.birthday.compareTo(b.birthday);
    }

    public static void main(String[] args) {
        List<LocalDate> datas = new ArrayList<>();
        datas.add(LocalDate.of(1982, 7, 15));
        datas.add(LocalDate.of(2011, 3, 2));
        datas.add(LocalDate.of(2013, 1, 28));

        datas.stream().map(Person::new).collect(Collectors.toList());
        
    }

    public int getAge() {
        return LocalDate.now().getYear() - birthday.getYear();
    }

}

~~~

+ [https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)
