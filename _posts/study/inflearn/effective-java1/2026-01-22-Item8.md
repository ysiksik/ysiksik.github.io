---
layout: post
bigtitle: '이펙티브 자바 완벽 공략 1부'
subtitle: 아이템 8. finalizer와 cleaner 사용을 피하라
date: '2026-01-22 00:00:01 +0900'
categories:
- effective-java1
comments: true

---

# 아이템 8. finalizer와 cleaner 사용을 피하라

# 아이템 8. finalizer와 cleaner 사용을 피하라

* toc
{:toc}

## 핵심 정리 
+ finalizer와 cleaner는 즉시 수행된다는 보장이 없다.
+ finalizer와 cleaner는 실행되지 않을 수도 있다.
+ finalizer 동작 중에 예외가 발생하면 정리 작업이 처리되지 않을 수도 있다.
+ finalizer와 cleaner는 심각한 성능 문제가 있다.
+ finalizer는 보안 문제가 있다.
+ 반납할 자원이 있는 클래스는 AutoCloseable을 구현하고 클라이언트에서 close()를 호출하거나 try-with-resource를 사용해야 한다.

~~~java

public class FinalizerIsBad {

    @Override
    protected void finalize() throws Throwable {
        System.out.print("");
    }
}

~~~

~~~java

public class App {

    /**
     * 코드 참고 https://www.baeldung.com/java-finalize
     */
    public static void main(String[] args) throws InterruptedException, ClassNotFoundException, NoSuchFieldException, IllegalAccessException {
        int i = 0;
        while(true) {
            i++;
            new FinalizerIsBad();

            if ((i % 1_000_000) == 0) {
                Class<?> finalizerClass = Class.forName("java.lang.ref.Finalizer");
                Field queueStaticField = finalizerClass.getDeclaredField("queue");
                queueStaticField.setAccessible(true);
                ReferenceQueue<Object> referenceQueue = (ReferenceQueue) queueStaticField.get(null);

                Field queueLengthField = ReferenceQueue.class.getDeclaredField("queueLength");
                queueLengthField.setAccessible(true);
                long queueLength = (long) queueLengthField.get(referenceQueue);
                System.out.format("There are %d references in the queue%n", queueLength);
            }
        }
    }
}


~~~

## Cleaner 사용법
+ 자원 반납용 안전망으로 사용할 수 있다.
  + PhantomReference를 사용한다.
  + 호출되리라는 보장이 없지만 없는 것 보다는 나을 수 있다.
+ 네이티브 피어 자원 회수
  + 단, 성능 저하를 감당할 수 있고 네이티브 피어가 심각한 자원을 가지고 있지 않을 때에만 해당한다.
  + 네이티브 피어가 사용하는 자원을 즉시 회수해야 한다면 close() 메소드를 호출해야 한다.

~~~java

public class BigObject {

    private List<Object> resource;

    public BigObject(List<Object> resource) {
        this.resource = resource;
    }

    public static class ResourceCleaner implements Runnable {

        private List<Object> resourceToClean;

        public ResourceCleaner(List<Object> resourceToClean) {
            this.resourceToClean = resourceToClean;
        }

        @Override
        public void run() {
            resourceToClean = null;
            System.out.println("cleaned up.");
        }
    }
}


~~~

~~~java

public class CleanerIsNotGood {

    public static void main(String[] args) throws InterruptedException {
        Cleaner cleaner = Cleaner.create();

        List<Object> resourceToCleanUp = new ArrayList<>();
        BigObject bigObject = new BigObject(resourceToCleanUp);
        cleaner.register(bigObject, new BigObject.ResourceCleaner(resourceToCleanUp));

        bigObject = null;
        System.gc();
        Thread.sleep(3000L);
    }

}

~~~java


~~~

~~~java

// cleaner 안전망을 갖춘 자원을 제대로 활용하는 클라이언트 (45쪽)
public class Adult {
    public static void main(String[] args) {
        try (Room myRoom = new Room(7)) {
            System.out.println("안녕~");
        }
    }
}


~~~


~~~java

// 코드 8-1 cleaner를 안전망으로 활용하는 AutoCloseable 클래스 (44쪽)
public class Room implements AutoCloseable {
    private static final Cleaner cleaner = Cleaner.create();

    // 청소가 필요한 자원. 절대 Room을 참조해서는 안 된다!
    private static class State implements Runnable {
        int numJunkPiles; // Number of junk piles in this room

        State(int numJunkPiles) {
            this.numJunkPiles = numJunkPiles;
        }

        // close 메서드나 cleaner가 호출한다.
        @Override public void run() {
            System.out.println("Cleaning room");
            numJunkPiles = 0;
        }
    }

    // 방의 상태. cleanable과 공유한다.
    private final State state;

    // cleanable 객체. 수거 대상이 되면 방을 청소한다.
    private final Cleaner.Cleanable cleanable;

    public Room(int numJunkPiles) {
        state = new State(numJunkPiles);
        cleanable = cleaner.register(this, state);
    }

    @Override public void close() {
        cleanable.clean();
    }
}


~~~

~~~java

// cleaner 안전망을 갖춘 자원을 제대로 활용하지 못하는 클라이언트 (45쪽)
public class Teenager {

    public static void main(String[] args) {
        new Room(99);
        System.out.println("Peace out");

        // 다음 줄의 주석을 해제한 후 동작을 다시 확인해보자.
        // 단, 가비지 컬렉러를 강제로 호출하는 이런 방식에 의존해서는 절대 안 된다!
        System.gc();
    }
}


~~~

## 권장하는 AutoCloseable
+ AutoClosable를 구현하면 Close라는 메소드를 구현할 수 있다
+ AutoCloseable를 구현한 클래스를 사용하는 쪽에서는 try with resource라는 문법인데, 이렇게 하면 자원을 다 쓰고 나서 이 블록 안에서 자원을 쓰고 정리해준다 

~~~java

public class AutoClosableIsGood implements Closeable {

    private BufferedReader reader;

    public AutoClosableIsGood(String path) {
        try {
            this.reader = new BufferedReader(new FileReader(path));
        } catch (FileNotFoundException e) {
            throw new IllegalArgumentException(path);
        }
    }

    @Override
    public void close() {
        try {
            reader.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

~~~


~~~java

public class App {

    public static void main(String[] args) {
        try(AutoClosableIsGood good = new AutoClosableIsGood("")) {
            // TODO 자원 반납 처리가 됨.

        }
    }
}


~~~

## 완벽 공략
+ p42, Finalizer 공격
+ p43, AutoClosable
+ p45, 정적이 아닌 중첩 클래스는 자동으로 바깥 객체의 참조를 갖는다.
+ p45, 람다 역시 바깥 객체의 참조를 갖기 쉽다.
